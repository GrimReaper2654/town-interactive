<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Town Interactive</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
        const sensitivity = 400; // larger is slower

        var canvas = document.getElementById("renderCanvas");

        var keyboard = {}; // This records what keys were pressed (used for movement and stuff)
        var sprint = 0; // used for sprinting
        var vy = 0; // Vertical velocity (used for jumping and physics)
        var r = {x:0, y:0} // rotation
        var typeing = false; // whether movement commands are ignored
        
        // records keypresses
        window.onkeyup = function(e) { keyboard[e.key.toLowerCase()] = false; }
        window.onkeydown = function(e) { keyboard[e.key.toLowerCase()] = true; }

        var isPointerLocked = false; // whether pointer is hidden

        // rotation and hiding mouse pointer stuff
        canvas.addEventListener("mousemove", e => {
        r.x = e.movementX;
        r.y = e.movementY;
        });

        canvas.addEventListener("click", async () => {
        if(!isPointerLocked) {
            await canvas.requestPointerLock({
                unadjustedMovement: true,
            });
        }
        });

        document.addEventListener("pointerlockchange", function() {
            isPointerLocked = !isPointerLocked;
        });

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
        
        // default values

        var musicvalue = 1

        // This creates a basic Babylon Scene object (non-mesh)
        var scene = new BABYLON.Scene(engine);

    	  var camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 5, -10), scene);

        // by default all music plays at volume
        var musicvalue = 1

        camera.speed = 0.2
        camera.minZ = 0.01
        camera.position.y = 1.8 // double the height of the ellipsoid for some reason
        
        const assumedFramesPerSecond = 60;
        const earthGravity = -9.81;
        scene.gravity = new BABYLON.Vector3(0, earthGravity / assumedFramesPerSecond, 0);
        camera.applyGravity = true;

        camera.ellipsoid = new BABYLON.Vector3(0.7, 0.9, 0.7);

        scene.collisionsEnabled = true;
        camera.checkCollisions = true;

        // This targets the camera to scene origin
        camera.setTarget(BABYLON.Vector3.Zero());
        
        var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 150, height: 150}, scene);

        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
        groundMaterial.emissiveColor = new BABYLON.Color4(0.8359375, 0.4140625, 0.234375)
        ground.material = groundMaterial;
        ground.checkCollisions = true;
        
        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 250, 0), scene)
        // const light = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(1, 50, 1), scene)
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        
        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 1;
        
        light.setEnabled(true)

        light.excludedMeshes.push(ground)
        
        scene.clearColor = new BABYLON.Color3(89/256, 147/256, 255/256) // The colour of the sky
        
        scene.fogMode = BABYLON.Scene.FOGMODE_EXP
        scene.fogDensity = 0.02
 
        // just adding a box
        const box = BABYLON.SceneLoader.ImportMesh("", "models/", "soundbox.obj", scene, function(newMeshes){
        newMeshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
        newMeshes[0].position = new BABYLON.Vector3(0, 10, 10);
        newMeshes[0].checkCollisions = true;
        });

        const soundbox = BABYLON.SceneLoader.ImportMesh("", "models/", "soundbox.obj", scene, function(newMeshes){
            newMeshes[0].position = new BABYLON.Vector3(0, 1, 0);
            newMeshes[0].checkCollisions = true;
        });

        const music1 = new BABYLON.Sound("Music", "music/verslaflamme.mp3"/*"music/e.wav"*/, scene, null, {
            loop: true,
            autoplay: true,
            volume: 0.4 * musicvalue,
            spatialSound: true,
            distanceModel: "exponential",
            rolloffFactor: 1.1,
        });

        music1.setPosition(new BABYLON.Vector3(0, 1, 0));

        // create a grey material for the cube
        var rockMaterial = new BABYLON.StandardMaterial("rockMaterial", scene);
        rockMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);

        var cloudMaterial = new BABYLON.StandardMaterial("rockMaterial", scene);
        cloudMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        cloudMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);

        var rocks = [];
        var clouds = [];

        function addRock(cx, cz, r, noRotate=false) {
            var x = (2+Math.random()*2-1)*0.1;
            var y = 0.25;
            var z = (2+Math.random()*2-1)*0.1;
            var rx = noRotate? 0 : Math.random()*Math.PI/24;
            var ry = noRotate? 0 : Math.PI*2*Math.random();
            var rock = BABYLON.MeshBuilder.CreateBox("box", { width: x, height: y, depth: z }, scene);
            rock.material = rockMaterial;
            rock.position = new BABYLON.Vector3(cx+Math.random()*r*2-r, -0.11+Math.random()/10, cz+Math.random()*r*2-r);
            rock.rotation.x = rx;
            rock.rotation.y = ry;
            rocks.push(rock);
        }


        function addCloud(cx, cz, r, h, noRotate=false) {
            var x = (2+Math.random()*2-1)*10;
            var y = 2+Math.random()*4;
            var z = (2+Math.random()*2-1)*10;
            var ry = noRotate? 0 : Math.PI*2*Math.random();
            var cloud = BABYLON.MeshBuilder.CreateBox("box", { width: x, height: y, depth: z }, scene);
            cloud.material = cloudMaterial;
            cloud.position = new BABYLON.Vector3(cx+Math.random()*r*2-r, h, cz+Math.random()*r*2-r);
            cloud.rotation.y = ry;
            clouds.push(cloud);
        }
        function addLight(x, y, z) {
            var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(x,y,z), scene);
            light.position = new BABYLON.Vector3(x, y, z);
            light.direction = new BABYLON.Vector3(0, -1, 0);
            light.diffuse = new BABYLON.Color3(1, 1, 1);
            light.excludedMeshes.push(ground);
            light.intensity = 0.1;
            light.setEnabled(true);
            console.log(light.position.x, light.position.y, light.position.z);
            clouds.push(light);
        }

        for (var i = 0; i < 200; i += 1) { // add rocks to the map
            addRock(0,0,50);
        }

        var maxx = 500;
        var maxz = 500;
        for (var i = 0; i < 30; i += 1) { // add clouds to the map (1 cloud is a group of small rectangles)
            var x = Math.random()*maxx*2-maxx;
            var z = Math.random()*maxz*2-maxz;
            var h = 75 + Math.random()*25;
            for (var j = 0; j < 15; j += 1) {
                addCloud(x,z,15,h,true);
            }
            //addLight(x,h-1,z);
        }

        // GUI, includes settings button
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const button = BABYLON.GUI.Button.CreateImageOnlyButton("settings", "images/settings.png");
        button.left = "-900px";
        button.top = "-450px";
        button.width = "40px";
        button.height = "40px";
        advancedTexture.addControl(button); 

        /* intermediate terminal code

        window.addEventListener("keydown", function (evt) {
        if (evt.keyCode === 8) {

            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    
            var input = new BABYLON.GUI.InputText();
            input.width = 0.2;
            input.maxWidth = 0.2;
            input.height = "40px";
            input.text = "";
            input.color = "white";
            input.background = "black";
            advancedTexture.addControl(input); 
        }

        });*/
       
        scene.onBeforeRenderObservable.add(() => {
            // Rotate the camera based on the mouse movement
            if (isPointerLocked) {
                if (r.x != 0) {
                    camera.rotation.y += r.x / sensitivity;
                    r.x = 0;
                }
                if (r.y) {
                    camera.rotation.x += r.y / sensitivity;
                    r.y = 0;
                }
            } else {
                // create a new 2D GUI element
                var guiTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                // create a text block and add it to the GUI
                var textBlock = new BABYLON.GUI.TextBlock();
                textBlock.text = "Click to enter the non-game game!";
                textBlock.color = "white";
                textBlock.fontSize = 72;
                guiTexture.addControl(textBlock);
                setTimeout(function() {
                    guiTexture.removeControl(textBlock);
                }, 1);
            }

            // Movement vectors in horizontal plane
            var forward = new BABYLON.Vector3(
                Math.sin(camera.rotation.y) * (keyboard['shift'] == 1 ? 0.02 : 0.1),
                0,
                Math.cos(camera.rotation.y) * (keyboard['shift'] == 1 ? 0.02 : 0.1)
            );
            var right = new BABYLON.Vector3(
                Math.sin(camera.rotation.y + Math.PI / 2) * (keyboard['shift'] == 1 ? 0.02 : 0.1),
                0,
                Math.cos(camera.rotation.y + Math.PI / 2) * (keyboard['shift'] == 1 ? 0.02 : 0.1)
            );
            var forwardSprint = new BABYLON.Vector3(
                Math.sin(camera.rotation.y)*0.25,
                0,
                Math.cos(camera.rotation.y)*0.25
            );

            // basic movement in the horizontal plane
            var moveDirection = BABYLON.Vector3.Zero();
            sprint -= 1;
            if ((keyboard['arrowup'] || keyboard['w']) && typeing == false) {
                //console.log('w');
                if (sprint > 0 && sprint < 23 && keyboard['shift'] != true) {
                    moveDirection.addInPlace(camera.position.y > 1 ? forwardSprint.scaleInPlace(1.2) : forwardSprint);
                    sprint = 5;
                } else {
                    moveDirection.addInPlace(camera.position.y > 1 ? forward.scaleInPlace(1.1) : forward);
                    sprint = 25;
                }
            }
            //console.log(sprint);

            if ((keyboard['arrowdown'] || keyboard['s']) && typeing == false) {
                //console.log('s');
                moveDirection.subtractInPlace(forward);
            }
            if ((keyboard['arrowright'] || keyboard['d']) && typeing == false) {
                //console.log('d');
                moveDirection.addInPlace(right);
            }
            if ((keyboard['arrowleft'] || keyboard['a']) && typeing == false) {
                //console.log('a');
                moveDirection.subtractInPlace(right);
            }

            // Jumping
            if ((keyboard[' '] && camera.position.y <= 1) && typeing == false) {
                vy += 0.15; // change this to change the jump power
            } 

            if (camera.position.y > 1) { 
                vy -= 0.01;
            }
            if (camera.position.y < 1) { // The earth is flat (literally)
                camera.position.y = 1;
                vy=0;
            }
            var vertivalMovement = new BABYLON.Vector3(0, vy, 0);
            moveDirection.addInPlace(vertivalMovement);
            // Sneaking
            var shift = new BABYLON.Vector3(0, -0.2, 0);
            if (keyboard['shift'] && typeing == false) {
                moveDirection.addInPlace(shift);
            }

            camera.position.addInPlace(moveDirection);
            //console.log(camera.position.x,camera.position.y,camera.position.z);
        });

        //});
        
        /*
        window.addEventListener("keydown", function (evt) {
        if (evt.keyCode === 32) {
            // add jump :)
        }
        });
        */

        /* Skybox
		var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:100.0}, scene);
		var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
		skyboxMaterial.backFaceCulling = false;
		skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
		skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
		skyboxMaterial.disableLighting = true;
		skybox.material = skyboxMaterial;
        */

        /* monkey code

        const monkeyMaterial = new BABYLON.StandardMaterial("monkeyMaterial", scene);
        monkeyMaterial.emissiveColor = new BABYLON.Color4.FromHexString("#5c3004");

        for(let k = 1; k<10; k++){

            for(let i = -2; i<3; i++){

                for(let j = -1; j < 3; j++) {

                    BABYLON.SceneLoader.ImportMesh("", "models/", "suzanne.obj", scene, function(newMeshes){
                    newMeshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
                    newMeshes[0].position = new BABYLON.Vector3(2.1*i, 1.1*k, 2.1*j);
                    newMeshes[0].material = monkeyMaterial;
                    });
                }
            }

        }

        */

        // this stuff is async stuff, DONT TOUCHY!!!
        return scene;
        };
        window.initFunction = async function() {
        var asyncEngineCreation = async function() {
            try {
            return createDefaultEngine();
            } 
            catch(e) {
            console.log("the available createEngine function failed. Creating the default engine instead");
            return createDefaultEngine();
            }
        }

        window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene                    
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
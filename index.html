<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Town Interactive</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
        const sensitivity = 500; // larger is slower

        var canvas = document.getElementById("renderCanvas");
        /*
        canvas.addEventListener("mouseover", function () {
            scene.onPointerMove = function () {
                canvas.style.cursor = "none";
            };
        });

        canvas.addEventListener("mouseout", function () {
            scene.onPointerMove = null;
            canvas.style.cursor = "default";
        });*/

        var keyboard = {}; // This records what keys were pressed (used for movement and stuff)
        var vy = 0; // Vertical velocity (used for jumping and physics)
        var r = {x:0, y:0} // rotation
        var typeing = false; // whether movement commands are ignored

        // records keypresses
        window.onkeyup = function(e) { keyboard[e.key.toLowerCase()] = false; }
        window.onkeydown = function(e) { keyboard[e.key.toLowerCase()] = true; }

        var isPointerLocked = false; // whether pointer is hidden
        /*
        var previousX = null;
        var previousY = null;

        var onPointerMove = function(evt) {
            r.x = evt.movementX || evt.mozMovementX || evt.webkitMovementX || 0;
            r.y = evt.movementY || evt.mozMovementY || evt.webkitMovementY || 0;
            
            if (r.x === null || r.y === null) {
                r.x = evt.clientX;
                r.y = evt.clientY;
            }
        }*/

        // rotation and hiding mouse pointer stuff
        canvas.addEventListener("mousemove", e => {
        r.x = e.movementX;
        r.y = e.movementY;
        });

        canvas.addEventListener("click", async () => {
        if(!isPointerLocked) {
            await canvas.requestPointerLock({
                unadjustedMovement: true,
            });
        }
        });

        document.addEventListener("pointerlockchange", function() {
            isPointerLocked = !isPointerLocked;
        });

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {

        // This creates a basic Babylon Scene object (non-mesh)
        var scene = new BABYLON.Scene(engine);
        const assumedFramesPerSecond = 60;
        const earthGravity = -9.81;
        scene.collisionsEnabled = true;
        scene.gravity = new BABYLON.Vector3(0, earthGravity / assumedFramesPerSecond, 0);

        // camera code
        var camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 5, -10), scene);
        camera.applyGravity = true;
        camera.ellipsoid = new BABYLON.Vector3(0.7, 0.9, 0.7);
        camera.checkCollisions = true;
        camera.attachControl(canvas, true);
        camera.speed = 0.2
        camera.minZ = 0.01
        camera.position.y = 1.8 // double the height of the ellipsoid for some reason
        
        // ground
        var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 150, height: 150}, scene);
        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
        groundMaterial.emissiveColor = new BABYLON.Color4(0.8359375, 0.4140625, 0.234375)
        ground.material = groundMaterial;
        ground.checkCollisions = true;
        // lighting
        var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(10, 50, 10), scene)
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        light.intensity = 1;
        light.setEnabled(true)
        light.excludedMeshes.push(ground)
        
        // This changes the colour of the sky and adds a fog mechanic
        scene.clearColor = new BABYLON.Color3(89/256, 147/256, 255/256) // The colour of the sky

        scene.fogMode = BABYLON.Scene.FOGMODE_EXP
        scene.fogDensity = 0.02
 
        // just adding a box
        const box = BABYLON.SceneLoader.ImportMesh("", "models/", "soundbox.obj", scene, function(newMeshes){
        newMeshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
        newMeshes[0].position = new BABYLON.Vector3(0, 10, 10)
        newMeshes[0].checkCollisions = true;

        });

        // soundbox (spatial audio) 
        const soundboxposition = new BABYLON.Vector3(0, 1, 0)
        const soundbox = BABYLON.SceneLoader.ImportMesh("", "models/", "soundbox.obj", scene, function(newMeshes){
            newMeshes[0].position = soundboxposition
            newMeshes[0].checkCollisions = true;
        });
        const music1 = new BABYLON.Sound("Music", "music/verslaflamme.mp3"/*"music/e.wav"*/, scene, null, {
            loop: true,
            autoplay: true,
            volume: 0.4 * musicvalue,
            spatialSound: true,
            distanceModel: "exponential",
            rolloffFactor: 1.1,
        });

        music1.setPosition(soundboxposition);

        // GUI, includes settings button
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const button = BABYLON.GUI.Button.CreateImageOnlyButton("settings", "images/settings.png");
        button.left = "-900px";
        button.top = "-450px";
        button.width = "40px";
        button.height = "40px";
        advancedTexture.addControl(button); 

        /* intermediate terminal code

        window.addEventListener("keydown", function (evt) {
        if (evt.keyCode === 8) {

            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    
            var input = new BABYLON.GUI.InputText();
            input.width = 0.2;
            input.maxWidth = 0.2;
            input.height = "40px";
            input.text = "";
            input.color = "white";
            input.background = "black";
            advancedTexture.addControl(input); 
        }
        });
       
        scene.onBeforeRenderObservable.add(() => {
            // Rotate the camera based on the mouse movement
            if (r.x != 0) {
                camera.rotation.y += r.x / sensitivity;
                r.x = 0;
            }
            if (r.y) {
                camera.rotation.x += r.y / sensitivity;
                r.y = 0;
            }

            // Movement vectors in horizontal plane
            var forward = new BABYLON.Vector3(
                Math.sin(camera.rotation.y) * (keyboard['shift'] == 1 ? 1 : 10),
                0,
                Math.cos(camera.rotation.y) * (keyboard['shift'] == 1 ? 1 : 10)
            );
            var right = new BABYLON.Vector3(
                Math.sin(camera.rotation.y + Math.PI / 2) * (keyboard['shift'] == 1 ? 1 : 10),
                0,
                Math.cos(camera.rotation.y + Math.PI / 2) * (keyboard['shift'] == 1 ? 1 : 10)
            );

            // basic movement in the horizontal plane
            var moveDirection = BABYLON.Vector3.Zero();
            
            if ((keyboard['arrowup'] || keyboard['w']) && typeing == false) {
                //console.log('w');
                moveDirection.addInPlace(forward);
            }
            if ((keyboard['arrowdown'] || keyboard['s']) && typeing == false) {
                //console.log('s');
                moveDirection.subtractInPlace(forward);
            }
            if ((keyboard['arrowright'] || keyboard['d']) && typeing == false) {
                //console.log('d');
                moveDirection.addInPlace(right);
            }
            if ((keyboard['arrowleft'] || keyboard['a']) && typeing == false) {
                //console.log('a');
                moveDirection.subtractInPlace(right);
            }

            // Jumping
            if ((keyboard[' '] && camera.position.y < 1.2) && typeing == false) {
                vy += 2; // change this to change the jump power
            }
            //console.log(keyboard);
            //console.log(camera.position);
            if (camera.position.y > 1) { 
                vy -= 0.4;
            }
            if (camera.position.y < 1) { // The earth is flat (literally)
                camera.position.y = 1;
                vy=0;
            }
            var vertivalMovement = new BABYLON.Vector3(0, vy, 0);
            moveDirection.addInPlace(vertivalMovement);

            // Sneaking
            var shift = new BABYLON.Vector3(0, -0.5, 0);
            if (keyboard['shift'] && typeing == false) {
                moveDirection.addInPlace(shift);
            }

            moveDirection.normalize();
            moveDirection.scaleInPlace(0.1);
            
            camera.position.addInPlace(moveDirection);
        });

        */
        
        /*
        window.addEventListener("keydown", function (evt) {
        if (evt.keyCode === 32) {
            // add jump :)
        }
        });
        */

        /* Skybox
		var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:100.0}, scene);
		var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
		skyboxMaterial.backFaceCulling = false;
		skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
		skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
		skyboxMaterial.disableLighting = true;
		skybox.material = skyboxMaterial;
        */

        /* monkey code

        const monkeyMaterial = new BABYLON.StandardMaterial("monkeyMaterial", scene);
        monkeyMaterial.emissiveColor = new BABYLON.Color4.FromHexString("#5c3004");

        for(let k = 1; k<10; k++){

            for(let i = -2; i<3; i++){

                for(let j = -1; j < 3; j++) {

                    BABYLON.SceneLoader.ImportMesh("", "models/", "suzanne.obj", scene, function(newMeshes){
                    newMeshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
                    newMeshes[0].position = new BABYLON.Vector3(2.1*i, 1.1*k, 2.1*j);
                    newMeshes[0].material = monkeyMaterial;
                    });
                }
            }

        }

        */

        // this stuff is async stuff, DONT TOUCHY!!!

        return scene;
        };
        window.initFunction = async function() {
        var asyncEngineCreation = async function() {
            try {
            return createDefaultEngine();
            } 
            catch(e) {
            console.log("the available createEngine function failed. Creating the default engine instead");
            return createDefaultEngine();
            }
        }

        window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene                    
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>